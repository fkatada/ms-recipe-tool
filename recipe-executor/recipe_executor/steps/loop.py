# This file was generated by Codebase-Generator, do not edit directly
"""
LoopStep: iterate over a collection of items, executing substeps for each item.
Supports template rendering, isolation via context cloning, error handling, and concurrency.
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Tuple, Union

from recipe_executor.protocols import ContextProtocol
from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.utils.templates import render_template

__all__ = ["LoopStep", "LoopStepConfig"]


class LoopStepConfig(StepConfig):
    """
    Configuration for LoopStep.

    Fields:
        items: Union[str, List[Any], Dict[Any, Any]]
        item_key: str
        max_concurrency: int = 1
        delay: float = 0.0
        substeps: List[Dict[str, Any]]
        result_key: str
        fail_fast: bool = True
    """

    items: Union[str, List[Any], Dict[Any, Any]]
    item_key: str
    max_concurrency: int = 1
    delay: float = 0.0
    substeps: List[Dict[str, Any]]
    result_key: str
    fail_fast: bool = True


class LoopStep(BaseStep[LoopStepConfig]):
    """
    LoopStep: iterate over a collection and execute configured substeps for each item.
    Supports async parallelism, staggered delays, structured history, and fail-fast behavior.
    """

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        validated = LoopStepConfig.model_validate(config)
        super().__init__(logger, validated)

    async def execute(self, context: ContextProtocol) -> None:
        # Avoid circular import for Executor
        from recipe_executor.executor import Executor

        cfg = self.config
        raw_items = cfg.items
        # Resolve items: render and path resolution if string
        if isinstance(raw_items, str):
            rendered = render_template(raw_items, context)
            items_obj = _resolve_path(rendered, context)
        else:
            items_obj = raw_items

        # Validate items
        if items_obj is None:
            raise ValueError(f"LoopStep: Items '{raw_items}' not found in context.")
        if not isinstance(items_obj, (list, dict)):
            raise ValueError(f"LoopStep: Items must be a list or dict, got {type(items_obj).__name__}.")

        # Flatten to list of (key, value)
        if isinstance(items_obj, list):
            items_list: List[Tuple[int, Any]] = list(enumerate(items_obj))
        else:
            items_list = list(items_obj.items())  # type: ignore

        total = len(items_list)
        max_conc = cfg.max_concurrency
        self.logger.info(f"LoopStep: Starting processing of {total} items (max_concurrency={max_conc}).")

        # Handle empty
        if total == 0:
            empty_res = [] if isinstance(items_obj, list) else {}
            context[cfg.result_key] = empty_res
            context[f"{cfg.result_key}__errors"] = []
            context[f"{cfg.result_key}__history"] = []
            self.logger.info("LoopStep: No items to process.")
            return

        # Prepare containers
        results: Union[List[Any], Dict[Any, Any]] = [] if isinstance(items_obj, list) else {}
        errors: List[Dict[str, Any]] = []
        history: List[Dict[str, Any]] = []

        # Concurrency control: None means unlimited
        semaphore: Optional[asyncio.Semaphore]
        semaphore = asyncio.Semaphore(max_conc) if max_conc > 0 else None

        # Executor for substeps
        executor = Executor(self.logger)
        plan = {"steps": cfg.substeps}

        fail_fast = cfg.fail_fast
        fail_fast_triggered = False
        completed = 0
        tasks: List[asyncio.Task] = []

        async def process_item(key: Any, value: Any) -> Tuple[Any, Any, Optional[str]]:
            # Clone context for isolation
            item_ctx = context.clone()
            item_ctx[cfg.item_key] = value
            # Expose index or key
            if isinstance(items_obj, list):
                item_ctx["__index"] = key  # type: ignore
            else:
                item_ctx["__key"] = key  # type: ignore
            try:
                self.logger.debug(f"LoopStep: Processing item {key}.")
                await executor.execute(plan, item_ctx)
                # Retrieve result
                out_val = item_ctx.get(cfg.item_key, value)
                self.logger.debug(f"LoopStep: Item {key} completed.")
                return key, out_val, None
            except Exception as exc:
                err = str(exc)
                self.logger.error(f"LoopStep: Error on item {key}: {err}")
                return key, None, err

        async def run_sequential() -> None:
            nonlocal fail_fast_triggered, completed
            for key, val in items_list:
                if fail_fast_triggered:
                    break
                k, out, err = await process_item(key, val)
                history.append({"key": k, "result": out, "error": err})
                if err:
                    errors.append({"key": k, "error": err})
                    if fail_fast:
                        fail_fast_triggered = True
                        break
                else:
                    if isinstance(results, list):
                        results.append(out)
                    else:
                        results[k] = out  # type: ignore
                    completed += 1

        async def run_parallel() -> None:
            nonlocal fail_fast_triggered, completed

            async def schedule(k: Any, v: Any) -> Tuple[Any, Any, Optional[str]]:
                if semaphore:
                    async with semaphore:
                        return await process_item(k, v)
                return await process_item(k, v)

            # Schedule tasks with optional delay
            for idx, (k, v) in enumerate(items_list):
                if fail_fast_triggered:
                    break
                task = asyncio.create_task(schedule(k, v))
                tasks.append(task)
                if cfg.delay and idx < total - 1:
                    await asyncio.sleep(cfg.delay)

            # Gather results
            for t in asyncio.as_completed(tasks):
                if fail_fast_triggered:
                    break
                try:
                    k, out, err = await t
                except Exception as exc:
                    # Unexpected exception
                    k = None
                    out = None
                    err = str(exc)
                    self.logger.error(f"LoopStep: Unexpected error: {err}")
                history.append({"key": k, "result": out, "error": err})
                if err:
                    errors.append({"key": k, "error": err})
                    if fail_fast:
                        fail_fast_triggered = True
                        break
                else:
                    if isinstance(results, list):
                        results.append(out)
                    else:
                        results[k] = out  # type: ignore
                    completed += 1
            # Cancel pending tasks on fail-fast
            if fail_fast_triggered:
                for t in tasks:
                    if not t.done():
                        t.cancel()

        # Execute loop
        if max_conc == 1:
            await run_sequential()
        else:
            await run_parallel()

        # Store outputs
        context[cfg.result_key] = results
        context[f"{cfg.result_key}__errors"] = errors
        context[f"{cfg.result_key}__history"] = history

        self.logger.info(f"LoopStep: Completed {completed}/{total} items. Errors: {len(errors)}.")


def _resolve_path(path: str, context: ContextProtocol) -> Any:
    """
    Resolve a dot-notated path against the context or nested dicts.
    """
    current: Any = context
    for part in path.split("."):
        if isinstance(current, ContextProtocol):
            current = current.get(part)
        elif isinstance(current, dict):
            current = current.get(part)
        else:
            return None
        if current is None:
            return None
    return current
