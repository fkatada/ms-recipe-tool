# This file was generated by Codebase-Generator, do not edit directly
from __future__ import annotations

import json
import logging
import shutil
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from recipe_executor.protocols import ContextProtocol
from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.utils.templates import render_template

from docpack_file import DocpackHandler


class DocpackCreateConfig(StepConfig):
    """
    Configuration for DocpackCreateStep.

    Fields:
        outline_path (str): Path to outline JSON file (may be templated).
        resource_files (Union[str, List[str]]): Comma-separated string or list of resource file paths (may be templated).
        output_path (str): Path for the created .docpack file (may be templated).
        output_key (Optional[str]): Context key to store result info (may be templated).
    """

    outline_path: str
    resource_files: Union[str, List[str]]
    output_path: str
    output_key: Optional[str] = None


class DocpackCreateStep(BaseStep[DocpackCreateConfig]):
    """
    Step that packages an outline JSON and resource files into a .docpack archive.
    """

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        super().__init__(logger, DocpackCreateConfig.model_validate(config))
        self.logger = logger
        self.config = self.config  # type: DocpackCreateConfig

    async def execute(self, context: ContextProtocol) -> None:
        # Render templates for configuration parameters
        raw_outline = render_template(self.config.outline_path, context)
        raw_output = render_template(self.config.output_path, context)
        raw_resources_config = self.config.resource_files
        raw_output_key = self.config.output_key

        self.logger.debug(
            "DocpackCreateStep config: outline_path=%s, resource_files=%s, output_path=%s, output_key=%s",
            raw_outline,
            raw_resources_config,
            raw_output,
            raw_output_key,
        )

        # Resolve and validate outline file
        outline_path = Path(raw_outline)
        if not outline_path.is_file():
            msg = f"Outline file does not exist or is not a file: '{outline_path}'"
            self.logger.error(msg)
            raise IOError(msg)

        try:
            with outline_path.open("r", encoding="utf-8") as f:
                outline_data = json.load(f)
        except json.JSONDecodeError as e:
            msg = f"Outline JSON parsing failed for '{outline_path}': {e}"
            self.logger.error(msg)
            raise ValueError(msg)
        except Exception as e:
            msg = f"Failed to read outline file '{outline_path}': {e}"
            self.logger.error(msg)
            raise IOError(msg)

        # Prepare and resolve resource file paths
        paths: List[Path] = []
        if isinstance(raw_resources_config, list):
            entries = raw_resources_config
        else:
            entries = [str(raw_resources_config)]

        for entry in entries:
            rendered = render_template(entry, context)
            for part in rendered.split(","):
                part = part.strip()
                if part:
                    paths.append(Path(part))
        self.logger.debug("Resolved resource paths: %s", paths)

        # Validate resources, skip missing files
        valid_paths: List[Path] = []
        for p in paths:
            if not p.is_file():
                self.logger.warning(f"Resource file not found and will be skipped: '{p}'")
            else:
                valid_paths.append(p)
        self.logger.debug("Valid resource files: %s", valid_paths)

        # Resolve output path and ensure directory exists
        output_path = Path(raw_output)
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            msg = f"Failed to create directory for output path '{output_path.parent}': {e}"
            self.logger.error(msg)
            raise IOError(msg)

        # Detect duplicate filenames and handle automatic renaming
        resource_paths_to_package: List[Path]
        name_counts: Dict[str, int] = {}
        for p in valid_paths:
            name_counts[p.name] = name_counts.get(p.name, 0) + 1

        duplicates_exist = any(count > 1 for count in name_counts.values())
        if duplicates_exist:
            self.logger.debug("Filename conflicts detected, copying to temporary directory for renaming")
            with tempfile.TemporaryDirectory() as tmpdir_str:
                tmpdir = Path(tmpdir_str)
                name_index: Dict[str, int] = {}
                resource_paths_to_package = []
                for original in valid_paths:
                    name = original.name
                    count = name_counts.get(name, 0)
                    idx = name_index.get(name, 0)
                    if count > 1:
                        if idx == 0:
                            new_name = name
                        else:
                            new_name = f"{original.stem}_{idx}{original.suffix}"
                        dest = tmpdir / new_name
                        try:
                            shutil.copy2(original, dest)
                        except Exception as e:
                            msg = f"Failed to copy resource '{original}' to temp '{dest}': {e}"
                            self.logger.error(msg)
                            raise IOError(msg)
                        resource_paths_to_package.append(dest)
                        self.logger.debug("Copied '%s' to '%s'", original, dest)
                        name_index[name] = idx + 1
                    else:
                        resource_paths_to_package.append(original)
                # Create package with renamed resources
                try:
                    DocpackHandler.create_package(
                        outline_data=outline_data,
                        resource_files=resource_paths_to_package,
                        output_path=output_path,
                    )
                except Exception as e:
                    msg = f"Failed to create docpack '{output_path}': {e}"
                    self.logger.error(msg)
                    raise RuntimeError(msg)
        else:
            resource_paths_to_package = valid_paths
            try:
                DocpackHandler.create_package(
                    outline_data=outline_data,
                    resource_files=resource_paths_to_package,
                    output_path=output_path,
                )
            except Exception as e:
                msg = f"Failed to create docpack '{output_path}': {e}"
                self.logger.error(msg)
                raise RuntimeError(msg)

        resource_count = len(resource_paths_to_package)
        self.logger.info("Created .docpack at '%s' with %d resource files.", output_path, resource_count)

        # Store result in context if requested
        if raw_output_key:
            key = render_template(raw_output_key, context)
            result: Dict[str, Any] = {
                "output_path": str(output_path),
                "resource_count": resource_count,
                "success": True,
            }
            context[key] = result
            self.logger.debug("Stored docpack result in context under key '%s': %s", key, result)
