# This file was generated by Codebase-Generator, do not edit directly
import os
import glob
import json
import logging
from typing import Any, Dict, List, Union

import yaml

from recipe_executor.protocols import ContextProtocol
from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.utils.templates import render_template


class ReadFilesConfig(StepConfig):
    """
    Configuration for ReadFilesStep.

    Fields:
        path: Path, comma-separated string, or list of paths to read (may be templated).
        content_key: Template for the context key under which content will be stored.
        optional: If True, missing files are skipped instead of raising.
        merge_mode: Mode to merge multiple files: "concat" or "dict".
    """

    path: Union[str, List[str]]
    content_key: str
    optional: bool = False
    merge_mode: str = "concat"


class ReadFilesStep(BaseStep[ReadFilesConfig]):
    """
    Step to read one or more files, optionally parse JSON/YAML, and store content in context.
    """

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        validated: ReadFilesConfig = ReadFilesConfig.model_validate(config)
        super().__init__(logger, validated)

    async def execute(self, context: ContextProtocol) -> None:
        cfg = self.config
        # Render the key under which to store content
        rendered_key: str = render_template(cfg.content_key, context)

        # Resolve and normalize input paths
        raw_path = cfg.path
        paths: List[str] = []

        def expand_pattern(pattern: str) -> List[str]:
            matches = glob.glob(pattern)
            return sorted(matches) if matches else [pattern]

        if isinstance(raw_path, str):
            rendered_paths = render_template(raw_path, context)
            candidates = [p.strip() for p in rendered_paths.split(",") if p.strip()]
            for cand in candidates:
                paths.extend(expand_pattern(cand))
        elif isinstance(raw_path, list):
            for entry in raw_path:
                if not isinstance(entry, str):
                    raise ValueError(f"Invalid path entry type: {entry!r}")
                rendered_entry = render_template(entry, context)
                if not rendered_entry:
                    continue
                paths.extend(expand_pattern(rendered_entry))
        else:
            raise ValueError(f"Invalid type for path: {type(raw_path)}")

        results: List[Any] = []
        result_map: Dict[str, Any] = {}

        for path in paths:
            self.logger.debug(f"Reading file at path: {path}")
            if not os.path.exists(path):
                message = f"File not found: {path}"
                if cfg.optional:
                    self.logger.warning(f"Optional file missing, skipping: {path}")
                    continue
                raise FileNotFoundError(message)

            try:
                with open(path, mode="r", encoding="utf-8") as f:
                    raw_text = f.read()
            except Exception as exc:
                raise IOError(f"Error reading file {path}: {exc}")

            content: Any = raw_text
            ext = os.path.splitext(path)[1].lower()
            if ext == ".json":
                try:
                    content = json.loads(raw_text)
                except Exception as exc:
                    self.logger.warning(f"Failed to parse JSON from {path}: {exc}")
            elif ext in (".yaml", ".yml"):
                try:
                    content = yaml.safe_load(raw_text)
                except Exception as exc:
                    self.logger.warning(f"Failed to parse YAML from {path}: {exc}")

            self.logger.info(f"Successfully read file: {path}")
            results.append(content)
            result_map[path] = content

        # Determine final content based on read results and merge_mode
        if not results:
            if len(paths) <= 1:
                final_content: Any = ""
            elif cfg.merge_mode == "dict":
                final_content = {}
            else:
                final_content = ""
        elif len(results) == 1:
            final_content = results[0]
        else:
            if cfg.merge_mode == "dict":
                final_content = result_map
            else:
                segments: List[str] = []
                for p in paths:
                    if p in result_map:
                        part = result_map[p]
                        segment = part if isinstance(part, str) else json.dumps(part)
                        segments.append(f"{p}\n{segment}")
                final_content = "\n".join(segments)

        # Store aggregated content in context
        context[rendered_key] = final_content
        self.logger.info(f"Stored file content under key '{rendered_key}'")
