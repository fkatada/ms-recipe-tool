# This file was generated by Codebase-Generator, do not edit directly
import logging
import re
from typing import Any, Dict, List, Union, Literal

from recipe_executor.steps.base import BaseStep, StepConfig
from recipe_executor.protocols import ContextProtocol
from recipe_executor.utils.templates import render_template

# Regex to strip out raw blocks for nested rendering detection
_RAW_BLOCK_RE = re.compile(r"{% raw %}.*?{% endraw %}", flags=re.DOTALL)


def _has_unrendered_tags(s: str) -> bool:
    """
    Detect if the string still contains Liquid tags that need rendering,
    ignoring content inside {% raw %}...{% endraw %} blocks.
    """
    # Remove raw blocks so tags within them are not considered
    cleaned = _RAW_BLOCK_RE.sub("", s)
    return ("{{" in cleaned) or ("{%" in cleaned)


class SetContextConfig(StepConfig):
    """
    Configuration for SetContextStep.

    Fields:
        key: Identifier for the artifact in the context.
        value: JSON-serializable literal, list, dict, or Liquid template string.
        nested_render: If True, render templates recursively until no tags remain.
        if_exists: Strategy when the key already exists: "overwrite" or "merge".
    """

    key: str
    value: Union[str, List[Any], Dict[str, Any]]
    nested_render: bool = False
    if_exists: Literal["overwrite", "merge"] = "overwrite"


class SetContextStep(BaseStep[SetContextConfig]):
    """
    Step to set or update an artifact in the shared execution context.
    """

    def __init__(self, logger: logging.Logger, config: Dict[str, Any]) -> None:
        super().__init__(logger, SetContextConfig.model_validate(config))

    async def execute(self, context: ContextProtocol) -> None:
        key: str = self.config.key
        raw_value: Any = self.config.value
        nested: bool = self.config.nested_render
        strategy: str = self.config.if_exists
        existed: bool = key in context

        # Render the provided value, with optional nested rendering
        value: Any = self._render_value(raw_value, context, nested)

        # Apply the chosen strategy for existing keys
        if strategy == "overwrite":
            context[key] = value
        elif strategy == "merge":
            if existed:
                old_value: Any = context[key]
                merged: Any = self._merge(old_value, value)
                context[key] = merged
            else:
                context[key] = value
        else:
            raise ValueError(f"Unknown if_exists strategy: '{strategy}'")

        self.logger.info(f"SetContextStep: key='{key}', strategy='{strategy}', existed={existed}")

    def _render_value(self, raw: Any, context: ContextProtocol, nested: bool) -> Any:
        """
        Recursively render Liquid templates in the given value.

        - Strings are rendered via the template engine.
        - Lists and dicts are walked recursively.
        - If nested is True, strings are re-rendered until stable or no tags remain.
        """
        # Render string values
        if isinstance(raw, str):
            rendered: str = render_template(raw, context)
            if not nested:
                return rendered

            result: str = rendered
            # Continue rendering until no unrendered tags remain or no change
            while _has_unrendered_tags(result):  # type: ignore
                previous = result
                result = render_template(result, context)
                if result == previous:
                    break
            return result

        # Render list elements
        if isinstance(raw, list):
            return [self._render_value(item, context, nested) for item in raw]

        # Render dict values
        if isinstance(raw, dict):
            return {k: self._render_value(v, context, nested) for k, v in raw.items()}

        # Other types are passed through unchanged
        return raw

    def _merge(self, old: Any, new: Any) -> Any:
        """
        Shallow merge helper:
          - str + str => concatenation
          - list + list or item => append/extend
          - dict + dict => shallow merge (new keys overwrite)
          - mismatched types => [old, new]
        """
        # String concatenation
        if isinstance(old, str) and isinstance(new, str):  # type: ignore
            return old + new  # type: ignore

        # List merge or append
        if isinstance(old, list):  # type: ignore
            if isinstance(new, list):  # type: ignore
                return old + new  # type: ignore
            return old + [new]  # type: ignore

        # Dict shallow merge
        if isinstance(old, dict) and isinstance(new, dict):  # type: ignore
            merged: Dict[Any, Any] = old.copy()  # type: ignore
            merged.update(new)  # type: ignore
            return merged  # type: ignore

        # Fallback: wrap in a list
        return [old, new]  # type: ignore
